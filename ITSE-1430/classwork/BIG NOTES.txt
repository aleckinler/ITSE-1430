uh notes i guess
see sharp lololololol

---JANUARY 25---
KEYWORD - identifier important to the compiler
OTHER IDENTIFIERS are important to YOU, THE PROGRAMMER
a string - just a line of text (string literal is like, a qoute or someshit)
a type - a category of data (numerics, size of value, precision)
statements do not have values and types, expressions do! expressions output data, statements are more general i guess?
if data has a VALUE, then it has a TYPE
VARIABLES are EXPRESSIONS, and are NAMED MEMORY LOCATIONS (allows for access of data in short form)
Statements in C# end in a semicolon.
PRIMITIVE DATA TYPE - type known by the language (KEYWORDS) (almost always simple) ex. INT for Integer
C# has a lot! notable primitive types include integrals: SBYTE, SHORT, INT, LONG - BYTE, USHORT, UINT, ULONG
					          SIGNED - can contain negatives | UNSIGNED - only positive
LITERAL - CONSTANT VALUES(always INT) - fixed value set at the point of compilation
floating point values (FLOAT) have a whole number and a decimal: FLOAT(5-7 digits of precision), DOUBLE(12-15 prec.), DECIMAL(80 prec. really only used for finnancial calculations)
FLOAT literals are always considered DOUBLE
NEVER USE INTEGER VALUE FOR A BOOLEAN (true or false, a binary) VALUE NEVER!!!!!
char (character) 2 bytes - represents all characters that can be typed on a keyboard
char literals are enclosed with 'single quotes' and a SINGLE character ex. 'e' (CASE SENSITIVE)
string literals are enclosed with "double quotes" and a string (duh) ex. "hello"
STRING and INT are likely most common
DOUBLE and BOOL are second place
DECIMAL and CHAR are bronze
DateTime - what do you think this represents (theres also DateOnly and TimeOnly)
TimeSpan - measures duration, not UTC timecode
Guid - identifies unique computer systems (stands for globally unique identifier, basically a huge string)
VARIABLE DECLARATION is like this T(type) id(identifier)
VARIABLES should always be descriptive names that are NOUNS!!! ex. hoursWorked
VARIABLES are "camel-cased" by design (lowercase first word, uppercase on word boundary)
IDENTIFIER RULES (not-keywords) must start with a letter or underscore, then may be followed by letters, digits, or underscores
				cannot be a keyword (of course)
				cannot already exist in the scope (scope is the lifetime or your variables, ends at the block)
SCOPE is important to WELL DEFINED RULES (the longer a variable is used, the mor elikely it is to be misused)
LITERALS have a value and type, you can read them | VARIABLES have a value and type, you can write them or read them
**google c# definitely assigned rule

---JANUARY 27---
DONT CREATE VARIABLES YOU DONT NEED (its wasteful cmon man)
declare your variable THEN ASSIGN IT
good practice is to use an INITIALIZER - T id[Et];
DECLARING FUNCTIONS - [modifier] T(or void) id ([parameter]) { S* }
Console.WriteLine ( string ) - Console.ReadLine ( ) ->string
IF STATEMENT - if (Expression bool)
		   S;
USE CURLYS IF THERE IS MORE THAN ONE STATEMENT
dunno if this is java only but curly braces denote objects
RELATIONAL OPERATORS - Et relation Et - the operators are as follows >, <, =>, =<, !=, ==
L value (the L stands for left) must be writiable (thus it has to be a variable)
WHEN YOU SEE AN ASSIGNMENT, EVALUATE THE RIGHT SIDE FIRST!! (pretty much everything else is left associative)

---FEBRUARY 1---
**google chaining "if else if"
RELATIONAL OPERATOR ALWAYS RETURN BOOLEAN(type) - the answer is always either true or false
DECLARATION - declaring the existence of (usually functions or variables) something (including the neccesary info the compiler needs to refer to it)
DEFINITION - in addition to the declaration, this is the implementation of a function/variable/etc. (the compiler does not care about the implementation)
PARAMETERS vs ARGUMENTS
PARAMETERS do not exist outside of function definitions
ARGUMENTS are the data you pass to the function and compare with parameters
THE ORDER IN WHICH THE FUNCTION APPEARS DOES NOT MATTER
SIGNATURE OF A FUNCTION DECLARATION = modifier T(void) id ([parameters]) { }
parameters = T id{, T id}
parameters are nouns and camelCased (public facing, so always use descriptive parameter names)

CALL STACK FUNCTION - apparently very important - how every programming language works
the CALL STACK tracks function calls and thats it
EX. entry -> main -> add movie -> ReadString function (think about the plate stack analogy)
WITHIN A FUNCTION YOU MAY DECLARE LOCAL VARIABLES, when its done those variables are too

3 KINDS OF PARAMETERS - input parameters - input/output parameters - output parameters
INPUT PARAMETERS - most parameters, simple and easy to work with, refered to sometimes as passby value (you're only passing a copy of information into a parameter when you call a function, not the actual data)
so for the lifetime of that function call, you have 2 copies of that information (in this class, you are likely to only use input parameters)
IN C# INPUT PARAMETERS are notated as: T id

INPUT/OUTPUT PARAMETERS - refered to as passby reference, it takes a value, but may provide and updated value as a result. It is for changing a cariables value and having that seen by other functions
IN C# INPUT/OUTPUT PARAMETERS are notated as: ref T id
seems like input/output parameters suck man

OUTPUT PARAMETERS - the function caller provides no input, its technically write only
IN C# OUTPUT PARAMETERS are notated as: out T id
since its an output parameter, it still must be a variable, but the function cannot read the output parameter, it only provides the location that the parameter will write to when its done
dont trust user input, always write defensively and validate
FUNCTIONS THAT HAVE OUTPUT PARAMETERS ARE GARUNTEED TO HAVE WRITTEN A VALUE TO THAT PARAMETER

INTEGER DIVISION PROBLEM integer divided by an integer will always be an integer(?)
arithmetic operators must be the same type (this is where type coercion comes in)
type coercion is when the compiler IMPLICITLY changes the type of an expression
the compiler isnt actually changing any code, it only is for calculative purposes
when the compiler sees 10/3.0 the 10 would be considered a double (since a double is larger than an int) the result would also be a double
**google Modulo in C programming its weird but it returns the remainder of an integer division
COMBINATION OPERATORS - +=, -=, *=, /=, %= EX. x+=10 is equivalent to x=x+10

special case operators - x++, ++x, X--, --x
prefix increment, postfix inc, prefix decrement, postfix dec
increase or decrease variables by values of 1 ONLY
this shit only works with integral variables
if the result of your arithmetic is outside the range of its data type, garunteed ERROR

while statement - while (Eb)
		    S;
**google loop variant
do while - equivalent to the while statment BUT its a post test
do statement - so S while (Eb),

---FEBRUARY 8---
DO WHILE (executes code 1 or more times) *just a reminder mainly*
WHILE (executes code 0 or more times)
NUMERIC FORMAT SPECIFIERS
CONDITIONAL OPERATORS Ebool ? Etrue:Efalse (equivalent to if (Ebool) Etrue)
							  else Efalse
SWITCH statment (the most compicated, apparently)
Switch ( E )
{
	{case statment}*               *needed*
	{default statment}
};

case statement = Ecase : S;             Ecase must be unique within the statement
default statement = default : S;
THIS SHIT IS WAY FASTER THAN IF ELSE IF (and can end up producing less code total so thats cool)
a CONSTANT EXPRESSION is an expression that can be created at compile time
	this includes: literals, arithmetics, and Const 

FALLTRHOUGH (C# does not support this by design) so every case statment must end with break or return, or you get a compiler error
this is also the only place you are allowed to do 2 statements without a block statement (dont rely on this)
statement; break;(this break is exempt from the rule) another statment; would still need curlys

FINAL OPERATORS - HOLY SHIT
the logical operators! there are three:
AND, OR, NOT
&&   ||  !
LOGICAL OR IS HIGHER PRIORITY THAN AND, SO DONT MIX USE PARANS
**google SHORT CIRCUIT EVALUATION (improves performance and creates a good chain of actions)

just use var lol
ANYTHING CAN BE CONVERTED TO A STRING but not really the opposite is true

---FEBRUARY 10---
ALL STRING MODIFICATIONS REQUIRE A BRAND NEW STRING TO BE CREATED (so the original variable is not modified)
strings become less efficient as they become larger
String.Compare is a function that compares two strings and returns an int (handles null too)
[String.Compare(string,string)->int]
<0 | A<B
0  | A==B
>0 | A>B
STRINGS ARE IMMUTABLE!!!

heres some useful string functions (can be seen with [string]. or String.)
[string].StartsWith and [string].EndsWith
[string].Trim( ) -> string (removes all white space from a string) USEFUL FOR STRING COMPARISON
EX. "Hello" and " Hello " ARE NOT CONSIDERED EQUAL, BUT WOULD BE WITH TRIM

DA RUNTIME BABY!!!!!!!!!! OOOOOYEAAAA
Managed Apps : C# or VISUALBASIC | Unmanaged Apps: everything else
managed apps rely on Common Language Runtime(CLR), unmanaged apps run on proprietary runtime
C# compiles your code to run on the CLR (which is not a virtual machine)
CLR normalizes everything below it from eveything above it (i guess?)
CLR allows inter-operability to be feasable!
**YOU NEED TO GOOGLE LIKE ALL THIS SHIT (also its in the textbook so yeah)

---FEBRUARY 15---
STATEMENTS JUST DO SOMETHING
EXPRESSIONS HAVE A TYPE AND A VALUE
@ VERBATIM STRING
$ string interpolation
SCOPE REFERS TO VARIABLES! VARIABLES!!!!!!!

DRAWING -- PROGRAM (Object oriented programming demo)
Square - length, origin				Draw()
Rectangle - width, length, origin		Resize()
Circle - radius, center				Move()
Triangle a, b, c, origin			
THESE ARE DATA POINTS				THESE ARE FUNCTIONS

new T() = new instance of a type(class)
**google the difference between variables and instances

PUBLIC and INTERNAL are the only class modifiers (not refering to classes nested within classes)
if NOT SPECIFIED it defaults to internal
INTERNAL - ASSEMBLY ONLY - public to all of the code in the assembly it is declared in, but private to anything else
PUBLIC - its public fuck you think this means
PRIVATE - 